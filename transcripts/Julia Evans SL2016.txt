   Julia Evans.
   StrangeLoop 2016
   Live captioning by Norma Miller @whitecoatcapxg
   
   Alex:  Hello, everyone, hope everybody had a good lunch, and it looks like we've got a lot of people in here and for good reason, because Julia is awesome, and so I'm going to leave lots of time for Julia Evans, everyone.
   >> JULIA EVANS:  Hello, everyone. OK, today we're going to be talking about some of my favorite debugging tools. The idea is you kind of have this like Swiss army knife, except there are no sharp objects on it, except some of them turn out to be sharp objects. Anyway, another opening slide I have for this talk is Linux debugging tools you'll love. Which involves you talking to a charming penguin about network packets. So there's a lot of programming language and stuff at this conference, right, and there's this question of like, OK, I'm not going to talk about programming language at all, first, but one thing that Haskell and Fortran have in common is that when they talk to each other, they might all talk to each other using a computer network so kind of common theme I'm going be to talking about today is everything I'm going to be doing is stuff you can do on all programming language and we're going to be talking about the interfaces that programs use to talk to each other. So kind of the setting for this is sometimes I'll log into a computer and something will be like terribly wrong, right? It will be like boom! Today is an exciting day for you and you're like, what's happening?
     And one thing that I'm really starting to learn, and to try to believe in is that all bugs are sort of easy to solve and I don't mean this in this weird, this is easy, why do you think it's hard, but fundamentally if you can figure out what's going on, and if you have like the right tools to like it, you're like, oh, I see, I sent like anda instead of cat and it was supposed to be cat. I get it. Like, and if you have the right tools, everything gets a lot easier to do. Sometimes -- I used to have this idea of debugging of I had to be really smart and stare at the code and be like, I am a genius! Which happens occasionally, but not that often. It's much better to have the right tools and in particular if you're not scared to kind of like delve into what's happening and keep on uncovering further layers of abstraction until you find out the real problem, it can be really valuable. So instead of the normal ways of debugging where you read the code and you know the language, we're instead just going to be wizards. These are some of our magical tool kits. We're going to talk about it's going to be the best. If you don't know what these things are, good, please, stay because I'm going to tell you about them. And the kind of conversation that we're going to be having in this talk is the conversation where you're like, hello, which file did my program open and the operating system will be like, it's wrong.txt and you're like, OK, I'm can fix that. I'll just open right.txt instead. So this talk is going to be we're going to do three mysteries. Mysteries are easier to solve if you invented them yourself. So we're going be to able to solve all of them. We're going to have the case of the missing configuration file, the case of the slow program and the case of the French website and there's going be to some extra stuff at the end depending on how many minutes we have. More minutes, more stuff. OK, let's do the case of the missing configuration file. One thing that often happens to me is I'll write a configuration file and I'll start my program and it does not work, right? And it could either not work because I did the wrong thing or because I edited the wrong file. Who's ever edited a file and it was wrong? Like all of you, perfect. Right. But like how do you know? Right? A really classic example of this is bash rc versus bash_profile. If you edit bash rc, it's confusing like sometimes you can learn over time. But what if you don't know? You can read the documentation, but that's boring, so instead we're going to see strace, which is literally my fave-lery frame in the world. Strace is a thing that follows system call. The way system call works is you have a proper gentleman, I guess who's like, please can you open this file and they your operating system on the other side, operating systems know they're all kinds of wonderful things, in particular they know how to open files. So your operating system would be a file, and then your program answers, like please some bytes from this file. So the way you run strace is you take it and you run it on your program like bash. And then I was like, oh, you opened.bashrc and I'm like perfect, it was bashrc. And if I get it, it can't possibly read because it's done and then I'm done. I don't need to read any stupid documentation. Who wants to do that, right? That's not fun.
   I want to show you a little demo of strace, because it can be a little scary. It looks like this usually. If this is totally understandable to you, raise your hand. So some of you. Some of you are like, I get that, so yeah, one good thing to remember with strace is if you don't understand everything, it's OK, just use it judiciously and I'm be able to figure out a lot of what's going on a lot of the time. It's OK if you don't know what most system calls are. OK. So we won. An important thing to know about strace is it can make your system run like 50 times slower. Don't run it on your database, that would be bad. That's all you need to know. These are some of my favorite system calls. I think my first day at work in my current job, two and a half years ago, we have this script and the script was running a lot of commands and it was running the wrong commands a and it was Ruby script and I didn't want to read the code, because it was boring and we ran strace, and we're like strace, just tell us all the commands you ran and it just told me all the commands you ran and I was like, oh, that one was wrong, it should have been different. And then we instantly knew what was wrong, instead of having to read Ruby. Ruby is fine.
   [laughter]
   OK. So you can read write files, you can start programs and you can do network activity, right, and there are lots of other system calls that I love, but these are some of my favorites. There are a lot of really good flags, you can run output to a file. You can say follow every other subprocess ever. You can print the time that every system call got executed. It's really great. I like it so much that I wrote ha zine about it about how much I like it, two years ago, you can download it and print it on my website if you want. Or you can just read it.
   OK, right. Oh, yeah, so I said that strace is really slow. Another thing that you can use if, don't want to use strace because it's too slow is there's this thing called open SNP, which is new. I'm going to show you how to. We're going to see what files I can open on my computer right now. Oh, man, what's happening, who knows? It's like Google Chrome. Google Chrome is doing something browser blocking. In. You can also tell it I can I'm only interested in like one, you can tell it you're just interested in one specific program and it will just show you what files it's opening. And it opens up and it's good because guise fast and strace is slow. It only works on pretty new kernels.
   If you want to know more about eBPF, you should read his blog and you'll be excited too.
   Next up is the 3 slow programs. We have three. One is slow because it's using too much CPU time. One is slow because it's writing too much to disk and the last one is slow because it's waiting for a slow server and we don't know which one is which, I mean I do, but you don't. And they're called things like mystery 1, mystery 2, and mystery had 3 and we're not going to figure out which ones they are by reading the source code. We're going to figure out which ones they are by being wizards, obviously because that's the whole point of this talk.
   So I read this one called time, which tells you A, how long the program took and B sort of where it spends its time and so the interesting thing about this program is it spent 5% of its time on the CPU which meant that 95% of the time it was waiting. What are you waiting for? I don't know. So what we're going to do here is we're going to look into the kernel's soul it turns out that this is an easy thing to do. You find out in this case my process was 31728 and I was like what is the Linux kernel stack right now. There's a lot of stuff on the screen so if we erase most of it you're like, oh, TCP receive message. I know what that is. TCP is like networking and stuff, right? Great, it was the network, it was waiting for some kind of network stuff. IDK, right? But we now know so much more. We didn't need to know what the program was doing at all. I have the server, which is just like sleep 2, return hi: Perfect. So that was super-easy to do. We just needed to know that the Linux kernel will just tell you what it was doing.
   OK, mystery program No. 2. This one took 2.74 seconds and it present 99% of its time on the CPU. This one is not really a big mystery but I wanted to point out that not all problems could be solved by looking at system calls because if you're on the CPU you're just adding stuff up or something, right? The operating system doesn't care, other than it just needs to schedule you to run on the CPU, so the answer here is use a Python profiler, right? I don't know what's wrong with you. And in fact what this program was doing it was just adding up 14 million numbers which in Python takes 2.74 seconds. Which depending on how you feel about computers might be fast or slow. I have a little game anyway. Program No. 3. Program No. 3 is it says, oops, 94%. So you might be like, Julia, the 4% is basically the same as 99%. This is the same as before and I would be like, good observation, but you're wrong. The reason that you're wrong is that it splits up the amount of CPU time into user space time, and off-writing system time. So it's not really spending any time in user space, so the program itself isn't doing anything, but the operating system is spending all this time doing stuff. What is it doing? What's happening?
   >> Why? We're going to start out by running dstat and it prints out how much disk and CPU you're using every second. I have this demo slide because I'm supposed to do a demo now. Oh, no. OK.
   So I'm going to start this and then I'm going to run dstat really fast and hopefully it will work. Yeah, cool. Let me close this and then I can point to stuff before it goes off the screen. No, ctrl-C, so you can see it wrote 455k, 300 megabytes. And so we can see that this thing was writing stuff to disk. So that's cool, right? Like we've already learned a lot. But what's with the CPU usage? It's not that hard to write stuff to disk, is it? Why would it be so hard? What's wrong with you? So you might know we use top to figure out what's going on on computers. Who uses htop, htop is really cool and I love it. Who uses perftop? It's one of my favorite things. And basically what it does, is it can tell you which functions are running slowly on your computer. So instead of which programs, which functions inside those programs. Which is kind of crazy, right, so I'm going to start perf top right now and then I'm going to run my program and see what happens. Cool i R, it's happening. You see aesni and right? It's happening. Something is happening. What does it mean? But we have a clue now, we have an amazing clue which we did not have before about why our program is slow. I copied this here to make it bigger. So what does aes mean? Encryption!   It means encryption. I was writing this file to my home directory, and my home directory is encrypted. So it's a lot of work for it to write to my home directory. Which is really interesting, right? It's like it's only writing to disk, it's not using anymore if you're writing to an encrypted file system. Fascinating.
   OK, new mystery: The case of the French website. I live in Montreal, which is a bilingual city, so if you go to a website, it's constructed in either language, right? How does it know which language to show up in? Oops, no, no, I lost my slides. I'm so prepared.
   So I have this website on my computer right now and if I go to it in my browser it says hello, welcome to Strangeloop. Yay, everything is amazing! If I go to it in my terminal  -- what? Why doesn't it work?
   That it hates me? Is that what's happening?
   Let's find out what's happening.
   OK, now it works. No problem. So if I go to -- if if I get it with curl in my terminal then it's in French but this is the same website. Right? It's in English here and it's in French here. So like, what's happening? Why is it doing this? I don't know. I'm upset. So what I did find out is that there's this program called ngrep, is grep for your network, literally. I'm going to print out some of the network packets on my local network.
   So I start printing stuff out. Right now there's nothing happening so it doesn't print anything. Great. Something happened, let's ignore that. That's not important.
   OK, and now you can see bonjour, Strangeloop, right nothing happened. And then we can see hello, it says welcome to Strangeloop. This thing was the response, right? What was the request? So this is the browser request, and this one here is the boop, boop, boop, this is the curl request, right? So it's like get HTTP 1.1, blah, blah, blah and then Google Chrome said a lot of stuff, right, so curl was just like website, please, and Google Chrome was like, I have a lot of things to say, about how I like this website. One thing it specifically said about how it liked this website is it said accept language in US, so it said it would like the website in English, OK, cool, I can ask for a website in English, right?
   Whoop. Why does this website hate me now? I don't know. Maybe we should debug that, but we will not.
   [laughter]
   Oh, it crashed. Why did it crash? That's so interesting. No, not interesting in the middle of a demo, computer. OK, great.
   [laughter]
   So now that we're not worrying about the crashing web server, which is yet another mystery.
   [laughter]
   We're going to get the website and now it gives me the website in English because I asked for it in English and so this was kind of fun, right? Because programs are deterministic, right? Well, they're not deterministic, but they're logical, and generally they respond to the inputs you give them so if you just look at what those inputs are, sometimes you can figure out why they are. Great, where are we for time? Great, amazing we're exactly where I hoped we would be.
   The next thing I wanted to do was talk about perf, I think it's tragically misunderstood, the reason it's tragically misunderstood is because it's pretty badly documented. It does a lot of different things and it's in general a tool that you can use for permanence nam analysis and kind of why I think perf is interesting is it's pretty useful, right, you can run it on your computer to debug your programs. You all might be like, I don't write in C, why should I care? An exciting thing about perf and perf top is you can use it to debug your programs even if they're in Java or in Node. There's a program called Java map agent which can tell you exactly which Java functions are running on your computer through perf and Node has kind of the same thing and I think this idea that you can always see what's happening in your program at any given time is like really powerful and it makes me want to build it for other programming languages that don't have this. Anyway, what's perf how does it work? It has three different kinds of things that it does, one of them is it has hardware counters, it has a sampling profile and it lets you trace things.
   So I want to talk for a second about sampling versus tracing. So sampling is when you have a program that's kind of slow, you want to know why, and you take a bunch of little snapshots, right so you're like, OK you're running this encryption function, OK you're running the encryption function, OK you're running the encryption, OK, OK, OK, and you're like I guess it's all the encryption function all the time so you don't keep track of every single thing it does. And this is the way a lot of profilers work and it's incredibly incredibly useful.
   So but sometimes you have something that happens pretty infrequently. So I used to think that if something happened like 0.1% of the time, 0.1% of the time a lot? Who thinks it's a lot? Not many of you. Some of you think it's a lot. So sometimes it's not a lot. So 0.1% of the time is like one 1 in 1,000 times. And if you work on a little small thing that not many people use, maybe that happens once every few days and doesn't really matter, but if you have billions of things, then 1 in 1,000 times is a million times, right, so if something has that many and it's broken that many times is it's broken a million times a day.
   If something happens infrequently you'll often miss it and it's really important to have tracing tools, because tracing tools are tools that tell you everything that's happening, right so you're like every time this weird thing happens, tell me everything about it and this is why I love log files, this is why I love tracing systems and you can be OK, this thing happened only 4 times but all of those 4 times I'm really concerned about and I want to know everything about that. And I used to spend a long time trying to debug things with a sampling profiler when I needed to be doing was using a tracing tool, so it's important to know which one is which.
   We're going to start out by talking about hardware counters. Which are another different thing entirely. OK, so I think this is really fun to know about, I'm I also write Ruby, this is not that important if you write Ruby but I think it's important to know how fast computers are. Dan is going to yell at me because I'm going to get this wrong. So your CPU is right next to the cache called the L1 cache which is extremely close to it and it takes about 0.14 nanoseconds. It takes like this eonof time to get to Ram and if you're working on a program that's really performant you actually care about this and people were telling me, Julia, it's important to use your cache efficiently and how do I it's like this tiny thing inside my CPU, I can't see it, right, how am I supposed to know if I'm using my L1 cache? Right, this is helpful, it's just like a weird abstract idea and it turns out it's not a weird abstract identify. You can find out how it's working really easily using perf. I cannot remember these numbers really but I try to read it every so often and I'm like yeah, read 1 megabyte sequentially from disk, it's kind of hard, but it's good to think about. OK.
   And the way you can read figure out about your L1 cache message is you can used perf stat and you can be like hey, perf tell me how many L1 cache load misses. And it's like 40,7 a 7 and you're like, OK. Great. Heh-heh and the reason that I think this is interesting is not because it's something I use every day but I find it really helpful to remember that my computer is really fast and has all this really great stuff in it, and I'm like, OK, if I really need to know how to optimize or that's someplace I can go, and these tools are available and this stuff is on my computer. And this ran in 0.004 seconds and I'm like OK, there's no problem. I do not need to optimize this. Cool. So we know what a hardware counter is. Let's talk a little bit about the sampling profiler. Do I have so much time? Yeah, I can maybe even talk about how it works. OK, cool, so perf has a sampling profiler which is what happens when you run perf top. And so what you do is you say hey, perform this function, right? So you want to record what's happening, and the way this works is that there's like this subsystem in the Linux kernel which will like, when your program is stopped collect information on what it's doing and then like send up the information. So it's actually a ton of work that went into making this a thing and it will create this file called perf.data. And then you ask it for a report. And you were like, what were you doing, find? What was going on, man and it's like bleah! Right and it gets get dents. I find get dents kind of hilarious because it reminds me of a dentist. I don't know. It means it's going through directories and figuring out what's inside them and going over them.
   And you see it spends its time like decrypting stuff. So I was doing this on my home directory which is encrypted. Cool. This is a little hard to read, though, because I am like what is really happening, I don't get it. And therefore we have flame graphs. Flame graphs are one of my favorite things. The way a flame graph works is you spend all this time in this function and then it called that function above it and it called that function above it and then it called that function above it then that kind of narrows up, right, you see the shape of how your program is spending its time and this isn't just a perf thing, right? This is a generally a nice way to visualize performance.
   Which I really love. I tried to like sketch this out a little more here with a hand-drawn flame graph so you imagine you spend all of your time in main and then 20% of the time you go over to the panda function and then 80% of the time you go over to alligator and 10% of that is eating and anyway, 28% teeth. Heh-heh-heh-heh-heh heh. It's supposed to be a helpful diagram, I don't know.
   [laughter]
   And flame graphs don't just work with perf. These are all generated by this tool called flame graph.PL by Brendan Greg. And then it will make a really pretty SVG with all these colors. As far as I can tell the colors don't really mean anything. It just make it look like fire and you can tell. Maybe it means something. I don't know. The last thing it can do is trace system calls. It's exciting but doesn't really work that well. We talked about strace, as perf trace, we're not going to talk about that, because that's the main thing is because I don't understand it. So we are can talk about perf trace, so strace lets you take a process and see what system calls it's writing. Perf trace does this, also, and it does it quickly but it also doesn't work. It's like sorry, I lost all these events and I'm like, thanks I guess? At least you're telling me. Because it's nice to have the things that you want in the same tool, but I just did this yesterday for the first time and I decided to put it in this talk. So OK, yeah, you can trace different things like system calls and scheduling events. OK, cool, we still have a few more minutes so I can talk about more stuff. Great. So we talked about ngrep, and ngrep lets you look at internet traffic. I look for things that are on the internet, right, it's a super-great interface. A lot of the tools are super good so it's really fun to take advantage of them, so like one thing I really like to do is let's say I'm own a computer and it says all these networks are slow and you're like, whose fault is that because it could be the client's fault or it could be like the server's fault and the server could be responding slowly and you might not really trust the metrics frameworks on either side so one of the nice things to do is drop down and look at the network conversations and be like, how long did it really take, right from the time you sent the first packet to the time you sent the last packet and no one gets to mess with the data, right? And you could have a single source of truth. I like to use tcp dump and Wireshark. Tcp dump was something I was scared of for a long time. And I was like, oh, I can just save network traffic with tcp dump and then I don't need to worry. Maybe I can show you why I was scared of tcpdump for a second. So this is why.Ists like, what is happening, why does it say, oh, my God, right? Like ack1, win 442, anyway, it turns out that tcpdump is really useful to me even though I understand almost nothing. The reason is it you can just use tcpdump to save network traffic later. I one interesting thing is for basically all of these tools you can give it a filter and you're like, I only want traffic on port 80, this is called a Berkeley packet filter or like BPF. It's this really nice language. It's super fast. Generally I'd feel fine like running it in production as long as I don't write too much stuff to disk. And you can be hey, this is the traffic I'm interested in, please save it for me. You can filter out a lot of stuff, the filters are fast, they're compiled into like magic Pixie dust or something, and it's really wonderful.
   And it saves it into a pcap file. So pcap is magical chocolate chip cookies for packet analysis, which means that every tool understands pcap files and they're wonderful. This is a really great pattern: You just save what's happening and you go and analyze it later when you have time and there's not an incident and you're like, you can calm down. Oh, yeah, and BFF filters are pretty easy to write. Oh, oh, no, it's ip src I always get those wrong. So or you just try both and then it just works.
   Great. You can also do like print packets to your screen, you can be like, and then this is kind of like, sometimes incomprehensible beings but times you can read the contents of the packet and you can read something, like if I go to a website like that, no, no, no, it's not. There's too much noise. OK, that was a bad demo. That's what happens when you invent something on the spot.
   OK, cool, so we're going to talk about Wireshark for 10 seconds and then we're going done. So Wireshark is a packet analysis tool that looks like this. I kind of love it. I do not love what it looks like at the beginning, because this is confusing, because there's all this stuff, kind of like but it's actually OK, and Wireshark is actually a thing that you can use, if you have kind of like close your eyes and squint at it sideways and learn a few basic things about it. So one thing that you can do, I wrote like these exercises for using Wireshark at some point, to be like, it's OK, I promise, it says you can just search all your packets and I was just like, I only want the ones that have GET in this emand they said 5. And I was like, oh, 5 is a normal number. And the nice thing about this is this packet actually has an HTTP string in it and Wireshark knows everything about HTTP and the other thing is that it knows about other protocols and not just HTTP so if you're talk to a database it will be like, I know what you're trying to query, I understand queries, and you'll be like, who are you are you a magician? And it will be yeah, I'm Wireshark, I'm a magical shark that knows everything. And you're like, oh, my goodness, good thing you're on my side.
   [laughter]
   And it often works out. This is a neat thing you can do if you don't like statistics and conversations this is like the worst screenshot in the universe, and I'm sorry but all the way on the right are these numbers that tell you how long the whole request was and it was like that took 0.15 seconds. And sometimes I'm like, Wireshark, please tell me how long everything took and like the slowest thing was 3 milliseconds and I'm like, oh, everything is fine. So I guess my messages in this talk is if you learn your operating system tools you can debug all your programs in every program language. One thing that happened to me once was someone like, Julia and they were like it's in Erlang and I'm like, OK, sounds fun. And I don't know anything about Erlang but I ran strace on it and it said blah, blah, blah blah, lock. And I said lock is bad. And I said do you have a lock problem and they were like, yes, and they went in and fixed the lock problem and the website ran fast and I was like I'm amazing.
   [applause]
   And so you, too, can be a wizard, right and a lot of that stuff isn't that hard to learn. Like it takes some time and experimentation and you're like, why is it weird and what happens the packet? But you can totally learn all of it. One thing I did to help people to learn it is I wrote a zine with a really cute penguin on the cover. My friend drew the really cute penguin, but I wrote the rest of it and it goes through a lot of the stuff and I hope you'll read it. It's at jvns.ca/zines. Thank you.
   [applause]
   And I'm not going to take questions but you can talk to me after. Also there are some scenes and stickers on the front at that rail and if you're fast, you can get them.
   [laughter]
