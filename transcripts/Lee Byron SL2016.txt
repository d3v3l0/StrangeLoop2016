   Lee Byron
   StrangeLoop 2016
   Live captioning by Norma Miller @whitecoatcapxg.
   
   
   LEE BYRON: ... Caffeine sunken in, I hope. By the way, feel free if you want to take any pictures, that's totally cool, permission granted in advance. 
   Today I'm going to talk about GraphQL, which is a query language for API. I'll introduce GraphQL a little bit for those who haven't had an opportunity to check it out yet, but really what I want to focus on today is actually the problems that led us to GraphQL and the process of developing it over the course of the last four years and I hope some of the lessons that I learned in the process will be relevant to all the stuff that you guys are building every day. 
   So my name is Lee Byron, our team is responsible for building the libraries and the tools that help our teams build great products. I also work in a lot of our open source libraries, so I was an early contributor to React, I'm a creator and maintainer of... In product infrastructure, we run our team like a service, we're always working super-close to product teams to make sure that we're seeing the real problems that they're running into on a regular basis. And four years ago, we were working really closely with our iOS newsfeed team, they were working on a new version of our iOS app and they were struggling with actually just retrieving data from our servers, so that's where we wanted to go focus. 
   That problem ultimately led us to develop GraphQL. I know a lot of you haven't seen GraphQL let so I'll briefly show you what it means to use GraphQL. This is the hello world of GraphQL queries. I want to know my name I don't know how I forgot it but this is how I will get it done. This looks a little bit like JSON, right, and then within those things, you have stuff that they income look a little bit like object keys, we call them fields and fields themselves can have selection sets which lets us describe deeply recursive or nested data. We send this query as a string to a GraphQL server, and it gives us a response that looks a little bit like this and you can see that the response and the query have the same structure. This is important why a GraphQL is easy to describe and use. But of course we can request fields that have complex values, so here profile picture is a flex field, it's got information about the width and height of the image that we're going to get and you bet you can guess what this is going to look like when we run it, right? It's important to -- there's no equivalent of like flex star. This ensures that there's ambiguity of what you're going to get. That ends up being super-important. And you're going to get exactly what you ask for, nothing more and nothing less.
    But of course, and most importantly, GraphQL is designed not just to carry the qualities of one thing about you to smooth properties between them foe oh, if I want just my name but the names of all of my friends I might write a query like this.
   A REST API might expose a list of ...
   GraphQL lets us represent this in a way that's easy to understand. Also notice that when we asked for one field here, we're going to get it on every single item that comes back to that list. And of course we can do this as deeply as is necessary for whatever the data needs that we have for the app that we're building so if I want not just my friends and their names and I want the events that they're attending next I might write a query like this. We can continue to do this and naturally represent these queries at different levels and we can also pass this lets us customize the behavior of these fields. 
   The most common example of doing this is to paginate over lists. So here I want my first friend and the next event that they're going to attend. And this kind of query shows up all the time in Facebook apps, we have tons of interrelated data that all appear in a single view and it's critical that our mobile apps can show this kind of thing and do it over a typical slow, high latency mobile network. All right, so this is going to bring me so tomorrow of the motivations, and what led us to actually do this in the first place, why did we build a new thing? Well, the original motivations for GraphQL were efficiency and predictability. 
   Facebook's newsfeed is full of interrelated stuff and the ability to request and retrieve that in one round trip was huge. Another big challenge that our iOS engineers were trying to keep track of is exactly what data is going to come back from our REST APIs.
   With GraphQL : Another benefit of GraphQL is that it's backed by a static type system and I feel like I probably don't need to elaborate the benefits of that to this crowd, but you know what we actually want to do when we're building a GraphQL server is define this type system. As we were doing this, we were inspired by RPC systems, like Cap'n Proto or Thrift.
   So let's take another look at that query from before. I kind of glossed over something. How do we even know that this is an OK query to run? Well, the type system told us that it was.
   Within every query, we can compare it to the type system that our server defines, and at the top of every request, we have a root type, we typically call it the query type and it define all the things that we can kind of start with. And for here we're asking for me. It's going to return to us a user object. From there we can kind of fold in, we can get deeper into these fields and we can see that the type system describes both the fields and the arguments that are available with types all along the way and in doing so it describes not only what's possible, but it also describes what's not possible. 
   Unlike SQL, which lets you perform, GraphQL only describes what you tell it it's going to be allowed to do. This is going to help us make sure that our GraphQL servers are performant, right, so we're only sorting on indexed columns, but also makes sure that we're actually thinking about how we design our APIs, that we separate across from our databases, and it gives us an opportunity to make sure we understand what we're trying to share. 
   So let's continue we ask for friends and we're going to get back a list of users. And now we can ask the name of our friends and the events that they're attending and events is going to return a list of the event type and then we can ask for the names of those events. So by having this type system we're able to prove that that query is valid before we even attempt to run it. So is this query valid? No, it's not valid, right? And of course, like we're smart people, so we can spot this mistake, but importantly the server can also spot the mistake, so without executing the query, the type system is used to determine if this query is invalid or not, and it can return a useful error if it is.
   That means that you can query information GraphQL but it also lets us interact with them in a way that we would hope a best in Class I DE would let us interact with our own codebases and we actually built and released a tool that does exactly this. It's called GraphiQLI by the way, documentation is a first-class citizen in GraphQL. It actually lives in your code rather than some other website or wiki or some other source you have for your documentation. And finally, and probably most importantly is that it gives more power to clients to allow APIs to provide features sooner, typically when using something like REST or most other web APIs, the server is going to be responsible for the shape of the data that's going to be returned and the clients are going to be responsible for the views that they're going to render. So the client is going to ask for some resource, and then the server is going to respond with the data that represents that resource. But what happens when that app needs to add some new feature. It's going to require some new data from that resource, and it turns out that models and views are pretty tightly coupled so we're going to have to go to our API team or into our API code and figure out how we're going to change that and that change might be breaking because we're now adding stuff to that shape and that means we're going to eventually release a new version of our API with that change included and that might take a little bit of time and efforts. But app developers need to be able to move quickly. Feature development is an iterative process, so we need to quickly change our API as we change our views and of course if the client is going to need more data than it got from that first response, it's going to immediately follow all those URLs that you just gave it and bombard the server. So now our hap is slow and everything sucks, right?
   GraphQL is going to really change this dynamic. Clients are going to express their requirements, their needs, with their data queries. We've given clients the ability to ask for what they need within reason, it has to be within the bounds of the type system, and so now, rather than requesting specific resources, our clients are requesting specific data shapes. And this is actually a real separation of concerns. The server knows what's possible, and the clients know what it needs, and so now the server doesn't need to know anything about the client and this means as clients evolve and add new features, they can do so without affecting the server. All right, so what does this look like in practice? Well, at Facebook, we have many different apps that all get data from one GraphQL API and since we ship new builds every couple of weeks we now have well over 1,000 older version also of these apps that unfortunately are still in heavy use, because people don't upgrade, apparently and they all hit the same GraphQL API and four years later we're still using version 1 of our API.
   Finally, I want to mention a few things that GraphQL is not: Common misunderstanding: GraphQL is not a way to talk to your database, it don't replease SQL. Language is for databases, they're going to have different -P semantics, the requirements that they have lead to different design decisions that what we had for web APIs. GraphQL is a way to talk to web APIs and it's intending to sit on top of your business logic rather than your database. GraphQL is also not about formal graphs. There's no requirement to model your data in terms of nodes or edges or explicit relationships and what we actually mean when we talk about graphs is the mental model that it lends us. We need this kind of interconnected data that makes it super-clear of what we're doing in our apps, it's this natural interconnectedness of the data that we're using all the time that makes GraphQL relevant rather than some kind of graph formalism. And maybe that helps explain where the name GraphQL came from. 
   So that's GraphQL, we're happy with what we built, but actually what I just showed you is super-different from what we are built four years ago. 
   Getting to where we are was rather a long journey, and I want to illustrate a little bit about what that process was like. So let's take a look at the history of GraphQL over the last four years. Hopefully this is insightful. And it can dispel the idea that ideas like this arrive fully formed. They definitely don't.
   Nick was actually one of the founding members of our team, product infrastructure, and up until this point he had been responsible for the data fetching and the privacy checking abstractions on our servers which make it possible for any view on Facebook.com to efficiently load safe data that we knew we could show the users without violating any privacy rules. And he had some ideas how we could extend these ideas to our APIs and he actually built a prototype of this in about three days, so from idea to initial things that worked, pretty short. But next came the initial development of what would become the first version of GraphQL. I was Nick and I started to work together to adapt super graph to solve the newsfeed's actual problems and Dan Schafer, who was an engineer joined our effort and he really did help make this possible. And things happened pretty quickly from there. Within three weeks we had something for that team to actually start using and a couple months after that, we had actually completed support for the entirety of newsfeed.
   And then in August of 2012, we actually shipped this app. We shipped new iOS newsfeed and as soon as other teams around our company saw one, that it was fast, and two, that that team was actually excited about the developer experience, we started to get indated really quickly with more requests to extend GraphQL to more teams in Facebook. First came profile, events, groups, and quickly the rest of Facebook. So this is when we bothered to form a team around GraphQL and we kind of made it a little bit more formal. And during this time what we did was focus on making sure that our type system still made sense as we continued to involve it to support more use cases and we also found a lot more varying use cases across our client teams, they were trying to do more things, interesting things and we started adding features to the GraphQL language and it got complicated and complicated and this is a long period of time and so it got really complicated. 
   And in January of 2013, Dan Schaeffer spoke publicly at the -- We got tons of people asking us when are you going to open source it? And we were like oh, oh, oh, pump the brakes, this was not supposed to be an open source announcement by any means, but the excitement was so awesome, it got us fired up, yeah, awesome, when can we share GraphQL? What does that mean? GraphQL is super tied in to how Facebook works and also we're not really proud of what GraphQL looks like now. 
   We glossed over a lot of details when we did that presentation. All those quirks and inconsistencies, and the assumptions that we made they were all still there. So we decided to reevaluate. We made improvements, fixed inconsistencies, and we fixed both the syntax and the semantics of GraphQL and that was a big project, that took many months and it required a lot more deliberate and careful process, especially in comparison to the early kind of rapid pace of development that characterized our first if you months. 
   This ended with us open sourcing a specification for GraphQL which describes how it works, as well as a new reference implement tanks that we wrote in Javascript, we did that not because we like Javascript, we do, is because it's an ubiquitous language. And any open source maintainers in the audience probably know what I mean when I say that open sourcing something is a beginning, not an end, right? We know that we're going to get a ton of feedback and so what we did is we released GraphQL as a technical preview, just to set expectations, that we knew things were going to change, right, kind of the equivalent of oh, it's beta ware, and over this period of time, we got a lot of implementation of GraphQL and other languages all really by the community, which was amazing and today you can actually find an implementation of GraphQL in almost a dozen languages. 
   And that brings us up to this week, after a little over a year, GraphQL is being used not only at Facebook, but in lots of other countries, and earlier this week, GitHub announced that its new API is going to be powered by GraphQL, which was super exciting. 
   And we launched our website to teach people more about how GraphQL works and how to use it. So it's been a wild four years, I've learned a lot. And I want to share some of that, especially the principles that we used when designing GraphQL that helped us the most along the way and I want to start with what's hopefully the host obvious and that's when you're designing anything, a language or a library or a tool, it's critical to start with a single important problem to solve. 
   For GraphQL, that was getting all the data that we needed for newsfeed on iOS over increasingly terrible will mobile network connections and this basically completely ruled out using REST as an option. We had tried this. We had quickly devolved with resources mashed together in a way that very clearly wasn't REST, so we had to abandon that for obvious reasons. Also, don't just solve any problem, soft the most important problem you can find. 2012 was a while ago now. But our mobile apps were truly terrible. In fact, when Zuck filed our first -- this was a trend that was already happening and we hadn't figured out how to be get at it. So this wasn't a theoretical probably any means, this was an existential threat to our company, failure to adjust to major shifts like this, like desktop to mobile, has crippled or killed major companies in the past. Starting with an important problem grounds you. 
   It keeps you honest about what you're trying to accomplish and it helps you drive the earlier prioritization of ideas. Giving clients control of the data that they get, one-round trip, these were all established within that initial prototype in response to the problem at hand. So remember to stay focused on the most important problem that you're solving and use that to crystallize what it is you're building. Mental models, they're so important to how we think as programmers. Everything we make is ethereal, right? But there's lots of different kinds of systems and different kinds of programmers and the mental models that we all use, they don't always match up and an important part of designing GraphQL for us was being unadashedly driven by the needs of the client. Hopefully it doesn't come as a surprise that a lot of great engineers are not top notch network engineers, our iOS engineers wanted to think in terms of the model objects that they were going to use and the JSON that they wanted to get from the network in order to hydrate those things. 
   Those who take a trivial look at GraphQL, they usually accuse us of being database nerds, where we've got our database hammer and everything looks like a nail and they see doom and gloom in the future, but the process is really the opposite. We're product people, we work with product teams and we designed the API that we wanted to use to build products. So I think if you're designing a new language or a library or a tool and especially one that combines different kinds of systems together, try to escape the mental model of how it works under the hood and put yourself in the shoes of the person who's going to be using that thing, how are they thinking and what is it that they're trying to accomplish?
   I love this tweet: Rethink established best practices. This was tweeted in response to us open-sourcing React at JSConf back in 2013, and I'm pretty sure it was meant to be poking fun at us, but this has become a mantra for our team.
   The biggest question is why didn't we use REST, SOAP, O data or any one of the other things that already existed out there and I think just because a best practice or even some other tool exists out there it doesn't necessarily mean that it's the right solution to your particular set of problems and none of these are right for ours. I do think it was important to honor and respect best practices. But it's also important not to be held hostage to Elon Musk talks about this. In order to do that, you need a good feedback loop and speaking of anything a good feedback loop, it's so important to have a first consumer of your library tool or language, not like first consumers, a first consumer. When you're designing something new it's easy to hear tons of stuff coming from the crowd about all the things you want to be able to design for and it's basically impossible to predict what all of those are going to be in the practice and the devil is in the details. 
   So what ends up happening is you basically guess, right? You guess. And if you're wrong on those guesses, those decisions stick around and live in your language, tool, or library forever. That it leads to poor tradeoffs. So our first team was newsfeed. We let their priorities drive our our decisions: What will we needed to do is was come up to a way for them to introduce this bit by bit. Because what ended up being super important because as we expand many the company we were able to do that one piece at a time. The ability to incrementally adopt a technology is very, very important for expanding its scope in the future.
   Speaking of adding features, your first response to every new feature request should be YAGNI. Do you know what this means? You ain't gonna need it. I didn't hear anyone. So I'm going to do this again, all right? I want to hear this from everyone. What do we say to adding new features? "You ain't gonna need it!"
   All right, good, good. This is one of my favorite lessons, and honestly it was the hardest for me to learn personally. Avoid implementing things that you foresee you need, in favor of things that you need to solve a real problem today. The burden of proof should lie on the new feature to prove that yes, truly we are gonna need it. Ask yourself, can we solve this problem in another way with the features and tools that we already have, and if we can, but it's awkward, just how awkward is it really? Can we live with it? Is it worth the cognitive cost? Every feature that we add to our libraries or syntax to a language, it's not just that it's expensive to implement. That's easy. It's more to learn and to teach and it's also more things for new features that might come in the future to bump into. We may anticipate ways of adding new features and YAGNI is a way to teach us to wait. 
   So if something totally sucks and we have one motivating example for why it sucks, but it's super-rare, maybe that's OK. We need real examples to understand how to prioritize changes, and during the redesign phase of GraphQL, I was talked out of a number of proposals with this argument.
   And speaking of that redesign effort, it's really important to avoid the second system syndrome. This idea comes from the book, the mythical man month by Fred Brooks. It's one of my favorite programming books. It claims that the first time you're going to build something, you know you're a beginner so you're naturally going to be conservative. 
   But the second time around, you have experience, you know what you're doing, you have success under your belt and so you pull out all the stops and you do all the things that you were too afraid to do the first time around and then you end up totally overdesigning it. As the prime designer of GraphQL language, this is absolutely something that I suffered from. 
   YAGNI can help, but I think -- abs the designer I have a propensity for ideas, I love to create new things and I tackled this new design with a lot of creative explanation and I was gung-ho about all of the ideas I came up and if I was the designer, then my teammate Nick should be considered the editor. His role was to be devil's advocate, you know, just an all-around pain in the ass and questioning all my proposals.
   And once I was able to convince Nick that something was worth it, he'd do a complete 180 and become a huge advocate for it, and this process also helped us clarify how we talked about GraphQL and the changes we were making to it which later helped pitch it to the rest of the company. But ultimately my editor, Nick, he ended up in the best position to persuade others of what we were coming, because he/him self had been persuaded, and so if you consider yourself the designer or the architect for whatever it is, you're building, consider which of your coworkers you think of as your primary editor, because it's really, really hard to keep those competing mentalities in one person's head.
    GraphQL changed a lot in those first few months, and we were able to do that because we sat right next to the people that we were affecting with those changes and later as GraphQL was used across the company it became harder and harder to make those changes. 
   Change is still possible, even in a big company like Facebook and we were prepared to open source GraphQL and when we were talking about that, we realized that as hard as it was going to be to change GraphQL now, it would be way harder when tons of companies were relying on this instead of just Facebook and so while I had been interested in redesign GraphQL for a while, it was really this open source that drove the motivation to make this happen.
   I think most of us open source our projects way too early. I hope that's not too bold of a statement to make. I love, and I deeply believe in open source, but I believe that it's the opposite of having a first client. If your idea is actually really great, then you're going to quickly get a ton of clients and that's not necessarily what you want for a young idea that still needs space and time to evolve. It can make it difficult to prioritize, it also removes a lot of that freedom to evolve and be able to talk to the one or three people that you're affecting with that evolution. 
   And finally, you know, GraphQL could have not worked out. It was lucky, and beneficial that it did work out for us, but it was a huge risk to build something new, especially at a time when we were really kind of facing an existential crisis about how we were going to turn things around for mobile at Facebook and in my experience, solving a really important problem like this is typically the time when most engineering managers and teams and companies encourage sticking to what works and avoid what might seem like taking unnecessary risks. When Nick first shared his prototype of super graph, he got a fair amount of push-back exactly like this, burr ultimately we were allowed to prove the idea, mostly because of early enthusiasm from that newsfeed team that we were working with.
   Some of the best projects I've had at Facebook they all started like this and what I've taken away from this is not just to take rings, but in particular trust experienced engineers like Nick to decide when that risk is worth taking and then hold them accountable to the choices. 
   So especially if you run a team or in a company try to push to your strongest engineers, especially if they think the time is right for something new. So from Nick's super graph in 2012, to powering newsfeed at Facebook to open-sourcing GraphQL last year to GitHub publicly announcing that their new API is powered by GraphQL just this week, GraphQL has been through a lot. We're still super excited but we're still exited about continuing to invest and make sure that it has more capabilities in the future, but even more than that we're looking forward to the contributions from the community as GraphQL becomes bigger than we are, so if you're interested in learning more, please check out GraphQL.org and thank you all for having me at Strangeloop.
   [applause]
   >> and I think I have, like a few minutes of questions.
    AUDIENCE:  So you mentioned that you did that refactor, that rewrite, and you changed some of the syntax, and you also mentioned that you haven't like released any breaking changes since you started using GraphQL four years ago, so how did you manage to not have any break changes in your clients.
   >> So the question was how did you manage to change syntax of the and semantics but. We've never made a breaking change to the data as effect of the API and in doing what we've just done, that might be considered of the first time that we've introduced V2 of the API but we're actually still working on that internally so even though it's been open sourced for a year now, internally we're still working on adapting all of our systems to a newer version GraphQL and in doing so, you know, we open sourced that a year ago. So it's a process iteratively to make sure we don't break anything along the way but we are in the process of setting up a new server and what it will do is accept both the old and the new language and when it receives the old language it will quickly transpond it to the new language. But we've still never made a change to the actual type system and the data within GraphQL. Other questions?
   >> Yes, I see a bunch of hands. Somebody please shout. All the way in the back there.
    AUDIENCE:  Say [inaudible] we don't have access to the database that those REST APIs are getting their data from, so maybe you set up a GraphQL database, are you necessarily going to be at the mercy of the slowest request to respond before you get all of your response back, or is there some options that take place that can speed that up?
   >> Great question. So say you're going to make a bunch of requests and stitch them together, will that be slow as the slowest request-dependent REST request? Yes, probably it will, because you need that data in order to fulfill that request, so you will wait on the longest of those requests to make it happen. One of the experiments is to add the ability to take one GraphQL query and then describe pieces where you see this subtree of the query. I care about, but I don't care about it coming immediately. And that gives us a little bit of streaming semantics to send the responses back. So we're playing with that idea and we don't anything like that but something to tackle on that waiting on the longest piece of data problem. Yes in the back there?
    AUDIENCE:  How do you deal with like if you didn't [inaudible] REST API?
   >> What happens if you're loading lots of stuff and one thing has an error? We have built into GraphQL and we did from the very beginning, a way to handle errors, and in fact, if you start reading more about GraphQL, the first thing that you might see is that by default types in GraphQL are knowable and you have to say something is nonknowable, which is usually exactly the opposite of what you would do. So it's like the inside-out-maybe type and what that does is it makes the assumption that any field in the request might fail, and if the field fails, and it's knowable, that's fine, you can return null in its place, and then we side load a list of errors that occurred during the preparation of that query, so we can say, blah, blah, blah, you load friends, you load events and at some point you hit a privacy error and you weren't allowed to see that event or this database was down and it dropped this particular profile picture or whatever. Something happens, you don't want bork, that query, so good example of that is if you have a newsfeed story, the actor is probably something, you know, the person who posted the newsfeed story is something that should be there. It would be really weird if you saw a newsfeed story show up and you didn't know who put it there. So we have that not nullable. Great question, though. Any other questions? I think I have time for one more. Here.
    AUDIENCE:  Is there any pass for subscriptions or streaming data? Question was are there any plans for streaming data or subscription in yes there are ha bunch of experiments for this. These are still early days, we actually have deployed some of those at Facebook. So we have two different ways of thinking about this, one that we call live queries, which is the ability to say, here's a whole query and then as any piece of the data anywhere in that query changes, send me a disk with that update and you might think of that as React for your data on the server. And then the other is subscriptions, which is layering GraphQL on top of a pub subsystem and that is one that we have in production and if you have ever commented on Facebook, both on the web and on or your iOS or Android device, you have seen GraphQL subscriptions in action. It also powers our live video feature. So we're still trying to figure out, like that's evolving quickly and it kind of leads back to some of the lessons I was talking about, of we like to keep some of these things experimental as possible early, because we've already changed that system a lot and we want to make sure that we don't say, here's a great way to do subscriptions, psych! It doesn't work. And so we want to make sure we get that working really well before building it into GraphQL. Thank you guys all for having me. It's been a pleasure.
   [applause]
