   Stuart Halloway
   StrangeLoop 2016
   Live captioning by Norma Miller @whitecoatcapxg
   
   Good morning; welcome to Strangeloop. My name is Stuart Halloway, I'm going to be talking about Clojure spec. I want to start with a very brief background of the things that I worry about every day that shape to some degree the characteristics of spec and why I want to use it. I'm a founder of a consulting company, Cognitect, originally relevant, that's since 2003, so I have a history of building things from other people and moving from project to project. I've been a Clojure committer. I also run the support team at Cognitect, so I get to really eat my dog food. When we make software, whether it's consulting or open source or product software, and it's working out great for people, I'm where the buck stops and we get to hear about it. So which shapes your life a lot. You know, compared to my early days as a consultant where you just write your software and you get to walk away and somebody else has to worry about it and I'm also responsible for operations for a lot of cloud software, so these things combine to have inculcated in me a real life cycle view of software that includes everything from, you know, before ideation, to you know, maintenance and, you know, working on a really brown field.
   And so when I think about these things, I want a lot of different things and I'm going to talk about three of them today. I want programs that are correct. I want systems that are correct, that are free from error, I want to be agile, I want to be able to move quickly and easily, modifying systems, changing them to meet needs, and I want my systems to be robust. I want them to be able to withstand adverse conditions, and as an industry, we have a lot of techniques and language level practices and other kinds of things that help us do this, and I can't cover them all today. But just a sampling of some that have been important to me, you see a lot of people using type systems or example-based testing which a lot of people start with calling unit testing to try to ensure that their programs are correct. To be agile requires a lot of different things, some people leverage encapsulation so I know that I can make a change over here and it's not going to cause the lights to turn off on that side of the building because those systems are encapsulated from each other. People also rely on IDEs that can automate refractoring. So I can take a large codebase and move it without having to touch tens of thousands of lines of code yourself and people have become increasingly to slam local concision, if anybody like me worked with the first versions of Java, you'll know exactly what I'm talking about when you want to have local consistency in order to be agile. Robustness is a developing field so I'm not going to lay down established practices down here, but you see people doing things like chaos simulating and fuzz testing and generation testing but I think we have a lot of room to think about those things. Now, Clojure as a language does not change all of that, right? 
   Clojure programmers do not say, you know, don't want tests, don't want types, don't want those things, but Clojure adds a particular spin that helps out in all of these areas. In terms of correctness, Clojure encourages programming with pure functions and Clojure also has a distinctive model for state, called the unified update model in some circles, and a model for flow with channels, and so these are all things that help you write correctly, you know, out the door. They help you write small things that you can compose about and reason about. For agility, Clojure's real buzzword is simplicity. If you make simple things you will be able to take the Legos and recombine them a different way, whereas if everything is all fused together, you get stuck and then, you know, at the language level, there's not necessarily a huge amount of help for robustness, but immutable data makes a big difference. If you know that the data in your system never changes, it's much easier to walk up to a system that's in trouble and figure out what's going on and I actually this is this is the stealth advantage of functional programming, wearing my ops hat is being able to walk up to a system and saying we know we're in trouble here, but the system is immutable. So and then I have this other term here, which I've put in all three rows and am about to define or characterize, at least. Which is systemic generality. And so the idea with systemic generality is that all domains use the same general-purpose data structures, where, in a lot of languages you would make up a new type, or make up a new class, or a new object to represent every entity in the system, Clojure encourages you to represent entities as, for example, maps or dictionaries, and so you might walk up to a system written in C-sharp or Ruby and find hundreds of classes representing different things in your domain, and in Clojure, you're going to find one class, and you don't even see it as a class, right, you're going to find maps and you're going to program with them and the advantage of this is really summed up by the quote which is, you know, it's better to have a large number of functions that all work on a single data type than to have a lot of disparate functions that work on specific data types. And in Clojure, this generality is extended by being systemic. So when you write Clojure programs, you have the ability to use these generic data structures everywhere. You can use them in your code, but you can also use them in your configures files which can be written in Eden. You can use them on the wire with Eden or with Freshen. You can use them in your durable store and this gives you the ability to write really small code and work in a very general way and have the algorithms that do that job be much better vetted because there's a small number of them. Right? That's kind of a downstream consequence that people don't necessarily think about. So instead of having 10,000 different functions in your system, you have 100, if you have 100, you can spend more time making sure those hundred functions are correct. You can spend more time making sure those hundred functions are fast.
   And then that means that you don't have to have toll booths everywhere in your system where you're crossing the boundary from is this the code? Is this the configuration? How many people have written something that you're totally happy with and then it falls over in production because there's something bust in an XML file somewhere or something shows up in ha bit of JSON that you didn't expect? So taking the systemic approach is really valuable. 
   And Clojure has been around for over a decade now, so we have some experience reports. And the fact of it is it's pretty good. People say great things. This is a quote that's been used in Clojure talks before, talking about developers, the very best programmers are producing amazing things, and they're doing so really quickly. So this is great, and if it were 2015, I would stop right now, and we could all hang out for a little bit and just chat and get to know each other or we could dig in and do a deep dive into the stuff that I just talked about, functional programming or immutable data or systemic generality. But I want to do something totally different today, which is talk about a problem that eats at the conscience of Clojure developers, and that problem is that this systemic generality idea is fantastic, except that we all work with specificity. Right? When you sit down to actually work in your domain, you're actually thinking about addresses or order items or models of the human body, or models of equipment on a factory floor. They're actually specific things, and so the Clojure promises, you know, your life is going to be better if you talk about those specific things in a really general way. And so what happens is, people have to be disciplined in how they think about specificity, right? Clojure doesn't have specificity as a language objective. It's kind of the opposite. And so thinking about specific things is, you know, on you.
   And people go through two phases with that. If you're an outsider to Clojure, especially if you come from a world of static typing, it's just downright scary, right? Everything that you look at in your traditional programs that you're use today writing that shows you how this domain is different from that domain and what's interesting about your domains, appears to be gone in Clojure, right, in the name of this generality.
   Then you use Clojure for a while, and you come to conclude that this is very powerful, and it's delivering assistance, not perfection, but assistance on writing correct programs and being agile, and writing robust programs and so then you start to sort of justify Clojure to your friends as a winning tradeoff. Right? We had to, you know, lose our ability to talk about specificity and we get this tradeoff and it is a clear win, right? It's five ounces of win and one ounce of pain or you'll come up your own numeric scoring system, but it seems like it's a big win and what I want to do is take the next step and say there's a way to approach this where this doesn't have to feel like a tradeoff, where it's all winning, and so you can program in the most generic way possible, and still deal with the specifics.
   And that's what Clojure spec does. Clojure spec is a standard, powerful integrated system in Clojure for specification and testing of your systems. And so this really answers the challenge of how do I program generically and talk about specific things and it answers it by saying not you have to be specific everywhere, which is what static typing and object oriented programming and the direction that they take you but saying that you can be specific in an a la carte way, running alongside your actual code, a separate place, and you can do this without sacrificing generality and then you can learning the specificity at your discretion. So it's an entirely opt-in proposition. You can not like spec and keep programming Clojure without spec, and spec won't care, right? The bits are really insensitive, their feelings will not be hurt if you choose not to use them. And so when you think about Clojure and spec together, you get a ton of new power that helps with these objectives that I have. Because you have a way to do declarative specification, it's easier to look at a system and sort of convince yourself that you're moving in the direction of having it work correctly. Also, you can automatically test your system with Clojure spec, so when you write your specs, you don't write tests and spec writes your tests for you. If you've ever spent time maintaining a test suite, should be very intrigued right now.
   Also, it allows you to instrument existing code at development time, so you can say, I want to run in a development mode where I enforce, you know, arbitrarily more complex programmatic validations of data and functions. And you can turn that on, and you can turn it on a little bit. Right? You can turn it to 4 or you can turn it all the way up to 11. You can actually call instrument all. Which would instrument every single system that had a spec. On the agility side, a lot of being agile is being able to walk up to your system and manipulate it. And spec gives you several things here. It gives you documentation. It gives you explanation, so when you have a piece of data, or a function, you've used incorrectly, spec will tell you what is incorrect about that use.
   Which is right, you know, you could put that under the rubric, good error messages. On the other side of that, though, spec also provides conformance and what conformance lets you do is say, don't tell me how my data was wrong, tell me how it was right. And so conformance allows you to get information about the ways in which the data conforms to your domain and oftentimes you're going to have and we'll see some examples, data that could be conformant to your needs in more than one way, so spec helps you understand what went wrong, it also helps you understand what went right. There are a few people in the world, Rich Hickey, for example, who think only in the abstract at all times and never actually touch keyboards and just manipulate things with their mind.
   But most of us benefit from examples and so one of the things that's fun about developing with spec is that as soon as you've made a spec and it can even be a very rudimentary one, you can say give knee example data or give me data function that is do this. Finally, the tools that spec provides can be available any time. So they're not available only at compile time, like type checking, they're not available only at test time, like a test suite. So you can use the same smarts in effect, at layer boundaries at run time. Without running new code. How many people here have had experience of having individual modules work pretty well but have to go and write a whole bunch of special stuff at the edges, just to make sure that things are happy? A lot of that, you get a lot of leverage for doing with spec, because once you've written the spec, you can use the spec for that job.
   So you're going to compare this to testing in static testing and Twitter is going to have fun with it, so here's your controversy slide, color coding and all. We'll spend a few minutes on this, and then we'll look at the actual use of spec and look at some code. So expressivity. Testing is very expressive. Because you have the arbitrary power of your language at your disposal. A lot of industry code is written in things like Java and C-sharp which are not very expressive and people do cooler stuff with Haskell or liquid Haskell or Idris. Spec is written in arbitrary Clojure code, so it has arbitrary expressivity just like testing does.
   Example tests really allow you to aspire to stakeholder correctness, right? Is it correct in the sense that the person that paid me to write it is happy?
   And spec also does that. Type systems, you know, are gradually moving in this direction, but if type systems actually solved this problem, then as soon as it compiled, everybody's job would be over, and statically typed systems wouldn't have bug databases, right, because we would know that static type correctness was equivalent to everybody was happy and we could just move on. Clearly not true. Testing tends not to be integrated in the language. There are a couple more languages that really do integrate it, but types are definitely integrate in your language. In fact they're kind of too integrated and so cool work is happening now to have types be less integrated with your language so you can opt in and opt out of them but generally the actual industry experience with types is you have to float them around everywhere. So you do something here which cascades over here and now you're over here and that's called a iack shave.
   >> Example tests are not specifications. Right? They're not, they tend to be of ad hoc things. Types are specification, although they're static in nature and spec is obviously a specification, because we named it that so it has to be, right? But there are specifications and are dynamic because they exist in the run time of your code, so you can do what you want to with them.
   So writing tests by hand is writing tests by hand. Hence my use of the word manual in the table. If you're writing test by hand, that's what you're doing, and then you have to babysit those tests. Type systems can actually be used to generate tests, but that's pretty rare, so that's a column where type systems, you know, as used in industry, could really, you know, take off. You could actually say given these types I want to automatically generate examples from these types and test from them. So that happens some. Could happen more and in spec it's the default. You write specs and you can get generative tests for you based on those specs.
   So testing is promoted for agility, but when you take a systemic view of testing for agility, it's very expensive because you know that you end up having to write a cascading set of tests, right? You have to write small tests, medium-sized tests, tests that test the boundaries. I'm not certainly not going to argue that we should stop writing example-based tests tomorrow. But they're expensive to maintain. Type systems as they're used are fragile because of overspecification and this goes back to the point about the general versus the specific. If you say really specific things all over your codebase, then when you change something, that causes an effect where things bounce around through the codebase and you have to deal with that.
   With spec, you can enforce a la cart. And then reach, again, example tests can reach everywhere. You could write unit tests that test your configuration file, but it's expensive. People tend to focus on their system and less energy in other places. He don't have type systems on wires or in storage or in configuration files and things like that, and of course because spec is built on top of Clojure, it has that kind of reach.
   So if you are coming for the why do I care? We're now done. This is why -- this slide is really why we built spec and what we were trying to do with it and then I'm going to use the next 20 minutes to talk about you know, show you some code and show you what it looks like using it. So having written specs, what kinds of things can you get help with? Well, you can find out what are the building blocks of my system, because you have this declarative specification, you can ask what invariants hold about data or about functions, you can say make checks for that and turn those on validation. You can get detailed explanations of what went wrong, you what went wrong. Automatic documentation, automatic example generation. You get the ability to turn on instrumentation at development time. This is a development-time feature. Turn on instrumentation that allows you to do small, medium or large and complex validations of your function calls and making sure that they're being called correctly. On the other side you can make sure that your functions are implemented correctly by using automatic generative testing and then you can leave assertions in your production system that leverage this same thing, so unlike with types and with tests which tend to be kind of gone, you know, once you're in production, these things are still there, and you can opt in to the exact amount of sort of protection you want. now, in order to see all this, you have to know Clojure. And in a longstanding Strangeloop tradition, I'm just going to assume you know Clojure and skip past these slides. I'm going to give this talk in other environments later, but for now, I'm just going to assume you know Clojure, because we got a lot to cover and we're going to talk about the actual building blocks here.
   So we're going to start with, you know, what does it mean to make a specification. Well, if you're Clojure programmer, you already know how to make specification, because all the predicates in Clojure are specs, and so these predicates cover things that you might think of as like primitive-like if you're looking at it from a Java language perspective. They also cover things that are class like so things am I a ratio or a string or a UUID. But it also includes predicates that cut across things that Java doesn't know anything about. So you can say things like am I a rational number? But it goes further than this. Any arbitrary predicate with act as a spec, so predicates are not limited to talk about the shape of things. They can also talk about the run-time values that they have. So you can have a spec that says is something a specific value like true or false or in the set 0, 1, and 2. You can talk about the ranges of things, is this a positive integer, is this a negative integer? If you can write a function that takes an argument and comes back true or false, you can write your own spec and you can use it in all these ways in your system.
   Of course we have collections and there is a rich set of support for collections but just to give you a little bit of a flavor for it, you can say, just what's in my collection, so call of string is this is a collection that needs to be full of strings and strings only.
   And then there's a lot of bells and whistles, so you can say I have a collect of integers, but that collection has to be of a vector shape and there have to be at least 5 integers, but there can't be more than 10, so a max count of 10 and by the way, all the integers are extinct. Right? You can have heterogeneous tuples, so this is a pain point sometimes in languages like Java. You can just walk up and say this thing is an nt followed by an nt and followed by a keyword: So this might be, you know, all of the different characters in a game and then their scores or who knows.
   Spec also has Boolean operators. You can say this thing has to be a string, but this is a thing that represents a string in my catalog system but it also has to start with sku.
   Or you can have an or so this is a system where people can say imagine people can identify themselves you can say that a person's identifier is either a positive integer or a string.
   Now, once you start making these compositions in more elaborate specs, you very quickly want to have name specs, right? You want them to be a first-class thing in the language so you can give them names, so the def form allows you to say things have names. So you can say my app sincerely ku is something that starts with sku, and now I'm going to be processing a CSV file so I'm going to use specs to describe an existing CSV file out in the world that has three columns in it. It could be a purchaser, it has to be a SKU and a positive integer which is the number of things of that SKU that the purchaser purchased or whatever. And the names here are global names, so these are name space names, the double colon in the closure is just a shorthand for in the current name space. so the important thing there is that when you have name specs, then we can share specs across projects, right? You can build a spec that's composed of some specs that I wrote and some specs that are in Clojure and all of these things can work together because we're not going to have any name collisions.
   Specs can also talk about syntax, so syntax is from the Greek, it's about the ordering of things. And if you're not actually a language implementer, you don't spend a lot of time necessarily thinking about the amount of time we as humans are using order to get meaning out of something. And so spec has a integrated regular expression library, it has cat nation, so this comes in order, followed by that, followed by that. It has alternatives, so the alt form says at this point in the syntax you could have a this, you could have a that. But these are not regular expressions of strings. These are regular expressions arbitrary data.
   
   And so when you think about what that looks like, you can now start to spec all the forms in the language itself, so this is a very small Clojure program that defines a function called greet that takes an argument called your name and returns a string which is hello, followed by your name.
   Well, the spec for that is a catenation followed by some metadata. That was optional. And then the body part is actually quite complicated and so you're taking advantage here of the fact of the that you can have named specs, so the B there named body or bodies, that thing is some complicated spec that describes what the shape of the internals of the Clojure function are.
   You can spec maps as information, and this slide is essentially the replacement for OO, right? When you think of OO as sort of encapsulation and entities and getters and setters and things like that. So this is saying I'm going to talk about a map but I am me not going to make you think a new thing. When you want to be specific you're not going to stop using the maps, you've just going to talk about your maps somewhere else and this spec you can imagine that this is a spec for an address book entry. That an address book entry consists of a name, a street, a city and a state and a zip. This whole system composes. You can take this and I don't even have to know what those things are. In fact, those specs don't have to exist, right? You can absolutely use name specs that don't exist up until the point that you have to program something and do something that wants to exist. But you can just talk about things and they don't even have to exist yet. So that's all about speccing data, but you can also spec function, so when you spec functions, well, what is a function, a function takes a list of arguments. Well, that's ordering so that's syntax. So here I have a function called index of that takes a string and something you're searching for and maybe a start position and you can spec that as a function. You can say the args any argument is a catenation of its functions. And then optionally a start position, and then the return is a nillable natural nt, so it returns the position of something it found, or if it didn't find a thing, it returns nil.
   So this is pretty cool, right, this allows you not to just talk about data but to talk about functions, but where it gets insanely cool is when you add the third element to functions which are semantic specifications. So what are the semantics of a function? It's the relationship between its arguments and its return value.
   This is fundamentally a dynamic thing. Right? You have to run the function to C, and this case I'm going to specify that it has two categoric outcomes. Either I can find something or I can't find it. 
   Well, if it's not found, the return had never been nil and if it is found, the return had better be less than or equal to the size of the search string. Right? That is a run-time thing.
   So the search string happened to have 30 characters in it if index returned 50, that's a buggy implementation. That couldn't possibly be true. So these are predicates of the actual behavior of the system.
   Now, notice at this point that I have given you a painfully whirlwind tour of a bunch of different things that you can say with spec, but I haven't actually said what happens in your program when you say all these things.
   And the answer is nothing.
   You say all of those things, and now you have, you know, a set of, you know, descriptions of data in your system sitting on yourself and you can do stuff with those descriptions. When can you do stuff with those descriptions? It is absolutely up to you. Which of the things do you want to do with those descriptions? It's absolutely also up to you. So we're going to dive in and take a look at them. So we'll start with validation. So validation is through a call called valid: So here I have a collection with A, B, C, and oops, and one of those things is not like the others? Right, oops is not a keyword, so valid returns false. Now, like most boolean functions, it's not a whole lot going on there. So what you want to know is not just that you're wrong, but what went wrong, so you can also say to me, explain to me the way in which this data does not match my spec. When. You get how it was wrong, the predicate was keyword, but you didn't match. You get what position it was wrong at. It's at position 3. 0, 1, 2, 3, we're 0-based by some weird tradition that started in the '70s.
   So now you have a detailed and precise pointer to where your problem happened and by the way this is all compositional. So if you have the JSON ball of mud from hell that's got something wrong with it, you know, 17 layers deep in that thing, then you're going to have a path through that thing, and a thing pointing you exactly where the problem happened. So it's nice to know how things wept wrong, but you also might want to know how things went right. So you can say conform, conform takes a spec and some data. In this case the data is actually program code and it tells you, and you can follow red line, it tells you how the data matched: Well the symbol of your name was in ... Every one of those five things in red represents a point at which this thing could have been a valid function but looks different and the spec for defn is a pretty rich thing. So it's a complicated spec and conformance gives you the ability to say, exactly how does this data perform? This also gets rid of a ton of ad hoc parsing in your programming:
   Spec gives names to that order and you can call it on an a la carte basis, if you're an experienced Clojure programmer, think of this as destructuring on steroids. This is data-driven destructuring, where you can drive the destructuring anywhere you want.
   Of course you get documentation and example data. So having spec, that letter grade is a function that gets the numeric grade and returns one of the letters, A, B, C, D, E, F, I have found that a lot of times, once I start speccing functions I don't actually put anything else in the doc string. I just let the doc string get the little spec addendum and that's all I need to know.
   You also get sample data. So the grading system that I had when I was in high school, a grade is a number between 1 and 100 and exercise a spec for me. It will generate examples that will conform to that spec and see how they conform. Now, when you're conforming as a number, how it conformed isn't very interesting, right, because it can only do one thing. So there's nothing in that second value that's interesting in that case. You can also, if you spec'd a function, exercise. So there's some function letter grade. I can say exercise this function for me and spec can generate data that represent inputs to the function, call the function for you had as many times as you want and return the output that results. And you can eyeball this and say, 94 should be an A, 60 should be a D. That all looks pretty good.
   Well, once you have this ability to generate data, including function calls in your system, you have access to some powerful capabilities for making your system more robust. You can instrument your system, so here's the scenario where I have a development time switch that says start server is going to be instrumented, I don't even know how it works, and then I'm going to call it incorrectly. It turns out port default is not legal. When instrumentation is turned on, I'm going to get a specific error that says port was the problem, that this spec failed, that the problem happened in this line of this module of my program.
   And this is not a static thing, this is a running thing. Right? This is not you're limited to what you can do at static time. This is you're running your program and you can turn this up to 11 and say something is going wrong here, I don't understand how this other subsystem is using what I'm calling. Maybe I'm not calling it correctly. Similarly, you can test automatically, so you can say, please check this for me. When you ask spec to check something for you, it's going to say generate an arbitrary number of inputs until you get tired, I think the default is 100, it's going to invoke the function for you and then it's going to check the return predicate to make sure the thing is structurally sound. And then it's going to check the function predicate to make sure the semantics are found and if it finds a problem it's going to shrink to a small repo before it goes back to you. So it's going to find some big hairy example that shows your program is broken and then it's going to shrink that heuristically down to. And of course you have assertions where you can take these same detailed error messages and sprinkle them where you want to in your production system, so you don't put them everywhere, but maybe on certain boundaries on your system or certain internal places where you have presumptions, you can turn on assertions.
   So in summary, spec is about doubling down on being a dynamic language. Right? Specification is a problem. But you don't need to be more static to solve it. Right? Specification is a dynamic idea, it's something that allows you to deliver simple specifications, separate from your code, and then pour in value, invalidation, in error checking and performance, in testing and adding exactly the parts of value that you want. So we're on Clojure alpha 12. I expect we will go beta soon. So this will be beta soon. People are already using it in production, but it is early days, we are eager to get people's experience reports, there's a ton of cool stuff that people at Strangeloop are doing we'd like to know how it works with spec. Try using little bits about the of it here, and little bits of it there. Be thoughtful about the danger areas and one danger area is definitely overspecification. Right? Spec has tried very hard to be as dynamic as possible and as flexible as possible, and to not require you to make overly specific statements, but you can make whatever statements you want. It's a general purpose programming language. So I predict five years from now I'll have consulting work going in and helping people making their specs more general and keeping things as general as they can. So that's definitely a challenge area. Also generating data. there are lots of interesting things to explore there. We don't have time today:
   I will be all in the hall. We don't have time for questions here but I will be out in the hall for the next couple of hours and if you're interested in talking more I'd love to hear from you. My name is Stuart Halloway and that was Clojure spec. Thank you.
